<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 5 Output Feedback | Optimal Control and Estimation</title>
  <meta name="description" content="Lecture notes for Harvard ES/AM 158 Introduction to Optimal Control and Estimation." />
  <meta name="generator" content="bookdown 0.33 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 5 Output Feedback | Optimal Control and Estimation" />
  <meta property="og:type" content="book" />
  
  <meta property="og:description" content="Lecture notes for Harvard ES/AM 158 Introduction to Optimal Control and Estimation." />
  <meta name="github-repo" content="hankyang94/OptimalControlEstimation" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 5 Output Feedback | Optimal Control and Estimation" />
  
  <meta name="twitter:description" content="Lecture notes for Harvard ES/AM 158 Introduction to Optimal Control and Estimation." />
  

<meta name="author" content="Heng Yang" />


<meta name="date" content="2023-07-01" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="stability.html"/>
<link rel="next" href="adaptivecontrol.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>



<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Optimal Control and Estimation</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a></li>
<li class="chapter" data-level="1" data-path="formulation.html"><a href="formulation.html"><i class="fa fa-check"></i><b>1</b> The Optimal Control Formulation</a>
<ul>
<li class="chapter" data-level="1.1" data-path="formulation.html"><a href="formulation.html#the-basic-problem"><i class="fa fa-check"></i><b>1.1</b> The Basic Problem</a></li>
<li class="chapter" data-level="1.2" data-path="formulation.html"><a href="formulation.html#dynamic-programming-and-principle-of-optimality"><i class="fa fa-check"></i><b>1.2</b> Dynamic Programming and Principle of Optimality</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="exactdp.html"><a href="exactdp.html"><i class="fa fa-check"></i><b>2</b> Exact Dynamic Programming</a>
<ul>
<li class="chapter" data-level="2.1" data-path="exactdp.html"><a href="exactdp.html#lqr"><i class="fa fa-check"></i><b>2.1</b> Linear Quadratic Regulator</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="approximatedp.html"><a href="approximatedp.html"><i class="fa fa-check"></i><b>3</b> Approximate Dynamic Programming</a></li>
<li class="chapter" data-level="4" data-path="stability.html"><a href="stability.html"><i class="fa fa-check"></i><b>4</b> Stability Analysis</a></li>
<li class="chapter" data-level="5" data-path="output-feedback.html"><a href="output-feedback.html"><i class="fa fa-check"></i><b>5</b> Output Feedback</a>
<ul>
<li class="chapter" data-level="5.1" data-path="output-feedback.html"><a href="output-feedback.html#state-observer"><i class="fa fa-check"></i><b>5.1</b> State Observer</a>
<ul>
<li class="chapter" data-level="5.1.1" data-path="output-feedback.html"><a href="output-feedback.html#general-design-strategy"><i class="fa fa-check"></i><b>5.1.1</b> General Design Strategy</a></li>
<li class="chapter" data-level="5.1.2" data-path="output-feedback.html"><a href="output-feedback.html#luenberger-template"><i class="fa fa-check"></i><b>5.1.2</b> Luenberger Template</a></li>
<li class="chapter" data-level="5.1.3" data-path="output-feedback.html"><a href="output-feedback.html#state-affine-template"><i class="fa fa-check"></i><b>5.1.3</b> State-affine Template</a></li>
<li class="chapter" data-level="5.1.4" data-path="output-feedback.html"><a href="output-feedback.html#triangular-template"><i class="fa fa-check"></i><b>5.1.4</b> Triangular Template</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="adaptivecontrol.html"><a href="adaptivecontrol.html"><i class="fa fa-check"></i><b>6</b> Adaptive Control</a>
<ul>
<li class="chapter" data-level="6.1" data-path="adaptivecontrol.html"><a href="adaptivecontrol.html#model-reference-adaptive-control"><i class="fa fa-check"></i><b>6.1</b> Model-Reference Adaptive Control</a>
<ul>
<li class="chapter" data-level="6.1.1" data-path="adaptivecontrol.html"><a href="adaptivecontrol.html#first-order-systems"><i class="fa fa-check"></i><b>6.1.1</b> First-Order Systems</a></li>
<li class="chapter" data-level="6.1.2" data-path="adaptivecontrol.html"><a href="adaptivecontrol.html#high-order-systems"><i class="fa fa-check"></i><b>6.1.2</b> High-Order Systems</a></li>
<li class="chapter" data-level="6.1.3" data-path="adaptivecontrol.html"><a href="adaptivecontrol.html#robotic-manipulator"><i class="fa fa-check"></i><b>6.1.3</b> Robotic Manipulator</a></li>
</ul></li>
<li class="chapter" data-level="6.2" data-path="adaptivecontrol.html"><a href="adaptivecontrol.html#certainty-equivalent-adaptive-control"><i class="fa fa-check"></i><b>6.2</b> Certainty-Equivalent Adaptive Control</a></li>
</ul></li>
<li class="appendix"><span><b>Appendix</b></span></li>
<li class="chapter" data-level="A" data-path="linear-system-theory.html"><a href="linear-system-theory.html"><i class="fa fa-check"></i><b>A</b> Linear System Theory</a></li>
<li class="chapter" data-level="B" data-path="appconvex.html"><a href="appconvex.html"><i class="fa fa-check"></i><b>B</b> Convex Analysis and Optimization</a></li>
<li class="chapter" data-level="C" data-path="the-kalman-yakubovich-lemma.html"><a href="the-kalman-yakubovich-lemma.html"><i class="fa fa-check"></i><b>C</b> The Kalman-Yakubovich Lemma</a></li>
<li class="chapter" data-level="D" data-path="feedbacklinearization.html"><a href="feedbacklinearization.html"><i class="fa fa-check"></i><b>D</b> Feedback Linearization</a></li>
<li class="chapter" data-level="E" data-path="slidingcontrol.html"><a href="slidingcontrol.html"><i class="fa fa-check"></i><b>E</b> Sliding Control</a></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Optimal Control and Estimation</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="output-feedback" class="section level1 hasAnchor" number="5">
<h1><span class="header-section-number">Chapter 5</span> Output Feedback<a href="output-feedback.html#output-feedback" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>Consider a continuous-time dynamical system
<span class="math display" id="eq:output-feedback-system">\[\begin{equation}
\begin{split}
\dot{x} &amp;= f(x,u)  \\
y &amp;= h(x,u)
\end{split}
\tag{5.1}
\end{equation}\]</span>
where <span class="math inline">\(x(t) \in \mathbb{X} \subseteq \mathbb{R}^n\)</span> the state of the system, <span class="math inline">\(u(t) \in \mathbb{U} \subseteq \mathbb{R}^m\)</span> the control (or input), <span class="math inline">\(y(t) \in \mathbb{Y} \subseteq \mathbb{R}^{d}\)</span> the output (i.e., measurement) of the state and control, and <span class="math inline">\(f,g\)</span> the evolution and measurement functions (which are sufficiently smooth).</p>
<div id="state-observer" class="section level2 hasAnchor" number="5.1">
<h2><span class="header-section-number">5.1</span> State Observer<a href="output-feedback.html#state-observer" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>For the system <a href="output-feedback.html#eq:output-feedback-system">(5.1)</a>, let us denote</p>
<ul>
<li><p><span class="math inline">\(X(x_0,t_0;t;u)\)</span> the solution at time <span class="math inline">\(t\)</span> with input <span class="math inline">\(u\)</span> and initial condition <span class="math inline">\(x_0\)</span> at time <span class="math inline">\(t_0\)</span>; when <span class="math inline">\(t_0 = 0\)</span>, we write <span class="math inline">\(X(x_0;t;u)\)</span></p></li>
<li><p><span class="math inline">\(Y(x_0,t_0;t;u)\)</span> the output at time <span class="math inline">\(t\)</span> with input <span class="math inline">\(u\)</span> and initial condition <span class="math inline">\(x_0\)</span> at time <span class="math inline">\(t_0\)</span>, i.e., <span class="math inline">\(Y(x_0,t_0;t;u) = h(X(x_0,t_0;t;u), u(t))\)</span>; when <span class="math inline">\(t_0 = 0\)</span>, we write <span class="math inline">\(y_{x_0,u}(t)\)</span>;</p></li>
<li><p><span class="math inline">\(\mathcal{X}_0\)</span> a subset of <span class="math inline">\(\mathbb{X}\)</span> containing the initial conditions we consider; for any <span class="math inline">\(x_0 \in \mathcal{X}_0\)</span>, we write <span class="math inline">\(\sigma^+_{\mathcal{X}}(x_0;u)\)</span> the maximal time of existence of <span class="math inline">\(X(x_0,\cdot;t;u)\)</span> in a set <span class="math inline">\(\mathcal{X}\)</span></p></li>
<li><p><span class="math inline">\(\mathcal{U}\)</span> the set of all sufficiently many times differentiable inputs <span class="math inline">\(u: [0,+\infty) \rightarrow \mathbb{U}\)</span>.</p></li>
</ul>
<p>The problem of state observation is to produce an estimated state <span class="math inline">\(\hat{x}(t)\)</span> of the true state <span class="math inline">\(X(x_0,t_0;t;u)\)</span> based on knowledge about the system <a href="output-feedback.html#eq:output-feedback-system">(5.1)</a> and information about the history of inputs <span class="math inline">\(u_{[0,t]}\)</span> and outputs <span class="math inline">\(y_{[0,t]}\)</span>, so that <span class="math inline">\(\hat{x}(t)\)</span> asymptotically converges to <span class="math inline">\(X(x_0,t_0;t;u)\)</span>, for any initial condition <span class="math inline">\(x_0 \in \mathcal{X}_0\)</span> and any input <span class="math inline">\(u \in \mathcal{U}\)</span>.</p>
<p>There are multiple ways for solving the problem of state observation (see e.g., <span class="citation">(<a href="#ref-bernard19book-observer">Bernard 2019</a>)</span>, <span class="citation">(<a href="#ref-bernard22arc-observer">Bernard, Andrieu, and Astolfi 2022</a>)</span>). Here we are particularly interested in the approach using a <em>state observer</em>, i.e., a dynamical system whose <em>internal state</em> evolves according to the history of inputs and outputs, from which a state estimation can be reconstructed that guarantees asymptotic convergence to the true state. We formalize this concept below.</p>
<div class="definition">
<p><span id="def:stateobserver" class="definition"><strong>Definition 5.1  (State Observer) </strong></span>A state observer for system <a href="output-feedback.html#eq:output-feedback-system">(5.1)</a> is a couple <span class="math inline">\((\mathcal{F},\mathcal{T})\)</span> such that</p>
<ol style="list-style-type: decimal">
<li><p><span class="math inline">\(\mathcal{F}: \mathbb{R}^{l} \times \mathbb{R}^{m} \times \mathbb{R}^d \rightarrow \mathbb{R}^l\)</span> is continuous</p></li>
<li><p><span class="math inline">\(\mathcal{T}\)</span> is a family of continuous functions indexed by <span class="math inline">\(u \in \mathcal{U}\)</span> where each <span class="math inline">\(\mathcal{T}_u: \mathbb{R}^l \times [0,+\infty) \rightarrow \mathbb{R}^n\)</span> respects the causality condition
<span class="math display">\[
\forall \tilde{u}: [0,+\infty) \rightarrow \mathbb{R}^m,\forall t \in [0,+\infty), u_{[0,t]} = \tilde{u}_{[0,t]} \Rightarrow  \mathcal{F}_u (\cdot,t) = \mathcal{F}_{\tilde{u}}(\cdot,t).
\]</span></p></li>
<li><p>For any <span class="math inline">\(u \in \mathcal{U}\)</span>, any <span class="math inline">\(z_0 \in \mathbb{R}^l\)</span>, and any <span class="math inline">\(x_0 \in \mathcal{X}_0\)</span> such that <span class="math inline">\(\sigma^+_{\mathbb{X}}(x_0;u) = +\infty\)</span>, any solution <span class="math inline">\(Z(z_0;t;u,y_{x_0,u})\)</span><a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a> to
<span class="math display" id="eq:observer-definition-1">\[\begin{equation}
\dot{z} = \mathcal{F}(z,u,y_{x_0,u})
\tag{5.2}
\end{equation}\]</span>
initialized at <span class="math inline">\(z_0\)</span> at time <span class="math inline">\(0\)</span> with input <span class="math inline">\(u\)</span> and <span class="math inline">\(y_{x_0,u}\)</span> exists on <span class="math inline">\([0,+\infty)\)</span> and satisfies
<span class="math display" id="eq:observer-definition-2">\[\begin{equation}
\lim_{t \rightarrow \infty} \Vert \hat{X}(x_0,z_0;t;u) - X(x_0;t;u) \Vert = 0,
\tag{5.3}
\end{equation}\]</span>
with
<span class="math display" id="eq:observer-definition-3">\[\begin{equation}
\hat{X}(x_0,z_0;t;u) = \mathcal{T}_u(Z(z_0;t;u,y_{x_0,u}),t).
\tag{5.4}
\end{equation}\]</span>
In words, (i) the state observer maintains an internal state (or latent state) <span class="math inline">\(z \in \mathbb{R}^l\)</span> that evolves according to the latent dynamics <span class="math inline">\(\mathcal{F}\)</span> in <a href="output-feedback.html#eq:observer-definition-1">(5.2)</a>, where <span class="math inline">\(u\)</span> and <span class="math inline">\(y_{x_0,u}\)</span> are inputs; (ii) an estimated state can be reconstructed from the internal state using <span class="math inline">\(\mathcal{T}_u\)</span> as in <a href="output-feedback.html#eq:observer-definition-3">(5.4)</a>; and (iii) the error between the estimated state and the true state (defined by a proper distance function <span class="math inline">\(\Vert \cdot \Vert\)</span> on <span class="math inline">\(\mathbb{X}\)</span>) converges to zero.</p></li>
</ol>
<p>If <span class="math inline">\(\mathcal{T}_u\)</span> is the same for any <span class="math inline">\(u \in \mathcal{U}\)</span> and is also time independent, then we say <span class="math inline">\(\mathcal{T}\)</span> is <em>stationary</em>.<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> In this case, we can simply write the observer <a href="output-feedback.html#eq:observer-definition-1">(5.2)</a> and <a href="output-feedback.html#eq:observer-definition-3">(5.4)</a> as
<span class="math display" id="eq:observer-definition-simple">\[\begin{equation}
\begin{split}
\dot{z} &amp;= \mathcal{F}(z,u,y) \\
\hat{x} &amp;= \mathcal{T}(z).
\end{split}
\tag{5.5}
\end{equation}\]</span></p>
<p>If <span class="math inline">\(\hat{x}\)</span> can be read off directly from <span class="math inline">\(z\)</span>, then we say the observer <a href="output-feedback.html#eq:observer-definition-simple">(5.5)</a> is <em>in the given coordinates</em>. A special case of this is when <span class="math inline">\(\hat{x} = z\)</span>, i.e., the internal state of the observer is the same as the system state.</p>
</div>
<div id="general-design-strategy" class="section level3 hasAnchor" number="5.1.1">
<h3><span class="header-section-number">5.1.1</span> General Design Strategy<a href="output-feedback.html#general-design-strategy" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div class="theorembox">
<div class="theorem">
<p><span id="thm:observerdesignmeta" class="theorem"><strong>Theorem 5.1  (Meta Observer) </strong></span>Let <span class="math inline">\(F: \mathbb{R}^p \times \mathbb{R}^m \times \mathbb{R}^d \rightarrow \mathbb{R}^p\)</span>, <span class="math inline">\(H: \mathbb{R}^p \times \mathbb{R}^m \rightarrow \mathbb{R}^d\)</span> and <span class="math inline">\(\mathcal{F}: \mathbb{R}^p \times \mathbb{R}^m \times \mathbb{R}^d \rightarrow \mathbb{R}^p\)</span> be continuous functions such that
<span class="math display" id="eq:meta-observer-zeta-hat">\[\begin{equation}
\dot{\hat{\xi}} = \mathcal{F}(\hat{\xi}, u, \tilde{y})
\tag{5.6}
\end{equation}\]</span>
is an observer for
<span class="math display" id="eq:meta-observer-zeta">\[\begin{equation}
\dot{\xi} = F(\xi,u,H(\xi,u)), \quad \tilde{y} = H(\xi,u),
\tag{5.7}
\end{equation}\]</span>
i.e., for any <span class="math inline">\(\xi_0,\hat{\xi}_0 \in \mathbb{R}^p\)</span> and any <span class="math inline">\(u \in \mathcal{U}\)</span>, the solution of the observer <a href="output-feedback.html#eq:meta-observer-zeta-hat">(5.6)</a>,
denoted by <span class="math inline">\(\hat{\Xi}(\hat{\xi}_0;t;u;\tilde{y}_{\xi_0,u})\)</span>, and the solution of the true system <a href="output-feedback.html#eq:meta-observer-zeta">(5.7)</a>, denoted by <span class="math inline">\(\Xi(\xi_0;t;u)\)</span>, satisfy
<span class="math display" id="eq:meta-observer-zeta-converge">\[\begin{equation}
\lim_{t \rightarrow \infty} \Vert \hat{\Xi}(\hat{\xi}_0;t;u;\tilde{y}_{\xi_0,u}) - \Xi(\xi_0;t;u) \Vert = 0.
\tag{5.8}
\end{equation}\]</span>
Note that the observer <a href="output-feedback.html#eq:meta-observer-zeta-hat">(5.6)</a> is stationary and in the given coordinates for system <a href="output-feedback.html#eq:meta-observer-zeta">(5.7)</a>. Indeed the internal state of the observer is the same as the system state.</p>
<p>Now suppose for any <span class="math inline">\(u \in \mathcal{U}\)</span>, there exists a continuous function (i.e., coordinate transformation) <span class="math inline">\(T_u: \mathbb{R}^n \times \mathbb{R} \rightarrow \mathbb{R}^p\)</span> and a subset <span class="math inline">\(\mathcal{X}\)</span> of <span class="math inline">\(\mathbb{X}\)</span> such that</p>
<ol style="list-style-type: decimal">
<li><p>For any <span class="math inline">\(x_0 \in \mathcal{X}_0\)</span> such that <span class="math inline">\(\sigma^+_{\mathbb{X}}(x_0;u) = + \infty\)</span>, <span class="math inline">\(X(x_0;\cdot;u)\)</span> remains in <span class="math inline">\(\mathcal{X}\)</span></p></li>
<li><p>There exists a concave <span class="math inline">\(\mathcal{K}\)</span><a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a> function <span class="math inline">\(\rho\)</span> and a positive number <span class="math inline">\(\bar{t}\)</span> such that
<span class="math display">\[
\Vert x_a - x_b \Vert \leq \rho (| T_u(x_a,t) - T_u(x_b,t) |), \quad \forall x_a,x_b \in \mathcal{X}, t \geq \bar{t},
\]</span>
i.e., <span class="math inline">\(x \mapsto T_u(x,t)\)</span> becomes injective on <span class="math inline">\(\mathcal{X}\)</span>,<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a> uniformly in time and space, after a certain time <span class="math inline">\(\bar{t}\)</span>.</p></li>
<li><p><span class="math inline">\(T_u\)</span> transforms the system <a href="output-feedback.html#eq:output-feedback-system">(5.1)</a> into the system <a href="output-feedback.html#eq:meta-observer-zeta">(5.7)</a>, i.e., for all <span class="math inline">\(x \in \mathcal{X}\)</span> and all <span class="math inline">\(t \geq 0\)</span>, we have
<span class="math display" id="eq:meta-observer-transform">\[\begin{equation}
L_{(f,1)} T_u(x,t) = F(T_u(x,t),u,h(x,u)), \quad h(x,u) = H(T_u(x,t),u),
\tag{5.9}
\end{equation}\]</span>
where <span class="math inline">\(L_{(f,1)} T_u(x,t)\)</span> is the Lie derivative of <span class="math inline">\(T_u\)</span> along the vector field <span class="math inline">\((f,1)\)</span>
<span class="math display">\[
L_{(f,1)} T_u(x,t) = \lim_{\tau \rightarrow 0} \frac{ T_u (X(x,t;t+\tau;u),t+\tau) - T_u(x,t) }{\tau}.
\]</span></p></li>
<li><p><span class="math inline">\(T_u\)</span> respects the causality condition
<span class="math display">\[
\forall \tilde{u}: [0,+\infty) \rightarrow \mathbb{R}^m, \forall t \in [0,+\infty), u_{[0,t]} = \tilde{u}_{[0,t]} \Rightarrow T_u(\cdot,t) = T_{\tilde{u}}(\cdot,t).
\]</span></p></li>
</ol>
<p>Then, for any <span class="math inline">\(u \in \mathcal{U}\)</span>, there exists a function <span class="math inline">\(\mathcal{T}_u: \mathbb{R}^p \times [0,+\infty) \rightarrow \mathcal{X}\)</span> (satisfying the causality condition) such that for any <span class="math inline">\(t \geq \bar{t}\)</span>, <span class="math inline">\(\xi \mapsto \mathcal{T}_u (\xi, t)\)</span> is uniformly continuous on <span class="math inline">\(\mathbb{R}^p\)</span> and satisfies
<span class="math display">\[
\mathcal{T}_u \left( T_u(x,t),t \right) = x, \forall x \in \mathcal{X}.
\]</span>
Moreover, denoting <span class="math inline">\(\mathcal{T}\)</span> the family of functions <span class="math inline">\(\mathcal{T}_u\)</span> for <span class="math inline">\(u \in \mathcal{U}\)</span>, the couple <span class="math inline">\((\mathcal{F}, \mathcal{T})\)</span> is an observer for the system <a href="output-feedback.html#eq:output-feedback-system">(5.1)</a> initialized in <span class="math inline">\(\mathcal{X}_0\)</span>.</p>
</div>
</div>
<div class="proof">
<p><span id="unlabeled-div-5" class="proof"><em>Proof</em>. </span>See Theorem 1.1 in <span class="citation">(<a href="#ref-bernard19book-observer">Bernard 2019</a>)</span>.</p>
</div>
<p>A simpler version of Theorem <a href="output-feedback.html#thm:observerdesignmeta">5.1</a> where the coordinate transformation <span class="math inline">\(T_u\)</span> is stationary and fixed for all <span class="math inline">\(u\)</span> is stated below as a corollary.</p>
<div class="corollary">
<p><span id="cor:observerdesignmetafixedT" class="corollary"><strong>Corollary 5.1  (Meta Observer with Fixed Transformation) </strong></span>Let <span class="math inline">\(F: \mathbb{R}^p \times \mathbb{R}^m \times \mathbb{R}^d \rightarrow \mathbb{R}^p\)</span>, <span class="math inline">\(H: \mathbb{R}^p \times \mathbb{R}^m \rightarrow \mathbb{R}^d\)</span> and <span class="math inline">\(\mathcal{F}: \mathbb{R}^p \times \mathbb{R}^m \times \mathbb{R}^d \rightarrow \mathbb{R}^p\)</span> be continuous functions such that <a href="output-feedback.html#eq:meta-observer-zeta-hat">(5.6)</a> is an observer for <a href="output-feedback.html#eq:meta-observer-zeta">(5.7)</a>.</p>
<p>Suppose there exists a continuous coordinate transformation <span class="math inline">\(T: \mathbb{R}^p \rightarrow \mathbb{R}^n\)</span> and a compact subset <span class="math inline">\(\Omega\)</span> of <span class="math inline">\(\mathbb{R}^n\)</span> such that</p>
<ol style="list-style-type: decimal">
<li><p>For any <span class="math inline">\(x_0 \in \mathcal{X}_0\)</span> such that <span class="math inline">\(\sigma^+_{\mathbb{X}}(x_0;u) = + \infty\)</span>, <span class="math inline">\(X(x_0;\cdot;u)\)</span> remains in <span class="math inline">\(\Omega\)</span></p></li>
<li><p><span class="math inline">\(x \mapsto T(x)\)</span> is injective on <span class="math inline">\(\Omega\)</span></p></li>
<li><p><span class="math inline">\(T\)</span> transforms the system <a href="output-feedback.html#eq:output-feedback-system">(5.1)</a> into system <a href="output-feedback.html#eq:meta-observer-zeta">(5.7)</a>
<span class="math display">\[
L_f T(x) = F(T(x),u,h(x,u)), \quad h(x,u) = H(T(x),u),
\]</span>
where <span class="math inline">\(L_f T(x)\)</span> is the Lie derivative of <span class="math inline">\(T(x)\)</span> along <span class="math inline">\(f\)</span>
<span class="math display">\[
L_f T(x) = \lim_{\tau \rightarrow 0} \frac{ T(X(x,t;t+\tau;u))  - T(x)}{\tau}.
\]</span></p></li>
</ol>
<p>Then, there exists a uniformly continuous function <span class="math inline">\(\mathcal{T}:\mathbb{R}^p \rightarrow \mathbb{R}^{n}\)</span> such that
<span class="math display">\[
\mathcal{T}(T(x)) = x, \quad \forall x \in \Omega,
\]</span>
and <span class="math inline">\((\mathcal{F},\mathcal{T})\)</span> is an observer for system <a href="output-feedback.html#eq:output-feedback-system">(5.1)</a> initialized in <span class="math inline">\(\mathcal{X}_0\)</span>.</p>
</div>
<p>Theorem <a href="output-feedback.html#thm:observerdesignmeta">5.1</a> and Corollary <a href="output-feedback.html#cor:observerdesignmetafixedT">5.1</a> suggest the following general observer design strategy:</p>
<ol style="list-style-type: decimal">
<li><p>Find an injective coordinate transformation <span class="math inline">\(T_u\)</span> (that may be time-varying and also dependent on <span class="math inline">\(u\)</span>) that transforms the original system <a href="output-feedback.html#eq:output-feedback-system">(5.1)</a> with coordinate <span class="math inline">\(x\)</span> into a new system <a href="output-feedback.html#eq:meta-observer-zeta">(5.7)</a> with coordinate <span class="math inline">\(\xi\)</span></p></li>
<li><p>Design an observer <a href="output-feedback.html#eq:meta-observer-zeta-hat">(5.6)</a>, <span class="math inline">\(\hat{\xi}\)</span>, for the new system</p></li>
<li><p>Compute a left inverse, <span class="math inline">\(\mathcal{T}_u\)</span>, of the transformation <span class="math inline">\(T_u\)</span> to recover a state estimation <span class="math inline">\(\hat{x}\)</span> of the original system.</p></li>
</ol>
<p>The transformed systems <a href="output-feedback.html#eq:meta-observer-zeta">(5.7)</a> are typically referred to as <em>normal forms</em>, or in my opinion, <em>templates</em>.</p>
<p>Of course, the general design strategy is rather conceptual, and in order for it to be practical, we have to answer three questions.</p>
<ul>
<li><p>What templates do we have, what are their associated observers, and what are the conditions for the observers to be asymptotically converging?</p></li>
<li><p>What kinds of (nonlinear) systems can be transformed into the templates, and how to perform the transformation?</p></li>
<li><p>How to invert the coordinate transformation? Is it analytical or does it require numerical approximation?</p></li>
</ul>
<p>In the following sections, we will study several representative normal forms and answer the above questions.</p>
</div>
<div id="luenberger-template" class="section level3 hasAnchor" number="5.1.2">
<h3><span class="header-section-number">5.1.2</span> Luenberger Template<a href="output-feedback.html#luenberger-template" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Consider an instance of the normal form <a href="output-feedback.html#eq:meta-observer-zeta">(5.7)</a> as follows:
<span class="math display" id="eq:Luenberger-linear-template">\[\begin{equation}
\dot{\xi} = A \xi + B(u,y), \quad y = C \xi,
\tag{5.10}
\end{equation}\]</span>
where <span class="math inline">\(A,C\)</span> are constant matrices, and <span class="math inline">\(B(u,y)\)</span> can depend nonlinearly on <span class="math inline">\(u\)</span> and <span class="math inline">\(y\)</span>.</p>
<p>For this template, we have the well-known Luenberger observer.</p>
<div class="theorembox">
<div class="theorem">
<p><span id="thm:LuenbergerLinear" class="theorem"><strong>Theorem 5.2  (Luenberger Observer) </strong></span>If the pair <span class="math inline">\((A,C)\)</span> is detectable (see Theorem <a href="linear-system-theory.html#thm:ltidetectable">A.3</a>), then there exists a matrix <span class="math inline">\(K\)</span> such that <span class="math inline">\(A-KC\)</span> is Hurwitz and the system
<span class="math display" id="eq:Luenberger-Linear">\[\begin{equation}
\dot{\hat{\xi}} = A \hat{\xi} + B(u,y) + K(y - C \hat{\xi})
\tag{5.11}
\end{equation}\]</span>
is an observer for <a href="output-feedback.html#eq:Luenberger-linear-template">(5.10)</a>.</p>
</div>
</div>
<div class="proofbox">
<div class="proof">
<p><span id="unlabeled-div-6" class="proof"><em>Proof</em>. </span>Define <span class="math inline">\(e(t) = \xi(t) - \hat{\xi}(t)\)</span>. In that case,
<span class="math display" id="eq:Luenberger-error">\[\begin{equation}
    \dot{e}(t) = [A - KC] e(t)
    \tag{5.12}
\end{equation}\]</span></p>
<p>Solving <a href="output-feedback.html#eq:Luenberger-error">(5.12)</a>, we obtain</p>
<p><span class="math display">\[\begin{equation}
    e(t) = \mathrm{exp}[(A - KC)t] e(0)
\end{equation}\]</span></p>
<p>Then, if the real components of the eigenvalues of <span class="math inline">\(A - KC\)</span> are strictly negative (i.e., <span class="math inline">\(A - KC\)</span> is Hurwitz), then <span class="math inline">\(e(t) \rightarrow 0\)</span> as <span class="math inline">\(t \rightarrow \infty\)</span>, independent of the initial error <span class="math inline">\(e(0) = \xi(0) - \hat{\xi}(0)\)</span>. From Theorem <a href="linear-system-theory.html#thm:ltidetectable">A.3</a>, we know that <span class="math inline">\((A,C)\)</span> being detectable implies the existence of <span class="math inline">\(K\)</span> such that <span class="math inline">\(A - KC\)</span> is Hurwitz.</p>
<p>If one is further interested in estimating the convergence rate of the Luenberger observer, then one can use the result from Corollary <a href="linear-system-theory.html#cor:bestconvergencerate">A.1</a>. Particularly, one can solve the Lyapunov equation
<span class="math display">\[
(A - KC)^T P + P (A - KC) = - I
\]</span>
to obtain <span class="math inline">\(P\)</span>. Then the convergence rate of <span class="math inline">\(\Vert e \Vert\)</span> towards zero is <span class="math inline">\(\frac{0.5}{\lambda_{\max}(P)}\)</span>.</p>
</div>
</div>
<p>The Luenberger observer is an elegant result in observer design (and even in control theory) that has far-reaching impact. In my opinion, the essence of observer design is twofold: (i) to simulate the dynamics when the state estimation is correct, and (ii) to correct the state estimation from observation when it is off. These two pieces of ideas are evident in <a href="output-feedback.html#eq:Luenberger-Linear">(5.11)</a>: the observer is a copy of the original dynamics (<span class="math inline">\(A \hat{\xi} + B(u,y)\)</span>) plus a feedback correction from the difference between the “imagined” observation <span class="math inline">\(C\hat{\xi}\)</span> and the true observation <span class="math inline">\(y\)</span>.</p>
<p>You may think the Luenberger template is restricting because it requires the system to be linear (up to the only nonlinearly in <span class="math inline">\(B(u,y)\)</span>). However, it turns out the Luenberger template is already quite useful, as I will show in the following pendulum example.</p>
<div class="examplebox">
<div class="example">
<p><span id="exm:pendulumLuenberger" class="example"><strong>Example 5.1  (Luenberger Observer for A Simple Pendulum) </strong></span>Consider a simple pendulum dynamics model
<span class="math display" id="eq:kbobserver-pendulum">\[\begin{equation}
x = \begin{bmatrix}
\theta \\ \dot{\theta}
\end{bmatrix}, \quad
\dot{x} = \begin{bmatrix}
\dot{\theta} \\
- \frac{1}{ml^2} (b \dot{\theta} + mgl \sin \theta)
\end{bmatrix} +
\begin{bmatrix}
0 \\
\frac{1}{ml^2}
\end{bmatrix} u, \quad y = \theta,
\tag{5.13}
\end{equation}\]</span>
where <span class="math inline">\(\theta\)</span> the angular position of the pendulum from the vertical line, <span class="math inline">\(m &gt; 0\)</span> the mass of the pendulum, <span class="math inline">\(l &gt; 0\)</span> the length, <span class="math inline">\(g\)</span> the gravitational constant, <span class="math inline">\(b &gt; 0\)</span> the dampling coefficient, and <span class="math inline">\(u\)</span> the control input (torque).</p>
<p>We assume we can only observe the angular position of the pendulum in <a href="output-feedback.html#eq:kbobserver-pendulum">(5.13)</a>, e.g., using a camera, but not the angular velocity. Our goal is to construct an observer that can provide a full state estimation.</p>
<p>We first note that the pendulum dynamics <a href="output-feedback.html#eq:kbobserver-pendulum">(5.13)</a> can actually be written in the (linear) Luenberger template <a href="output-feedback.html#eq:Luenberger-linear-template">(5.10)</a> as<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a>
<span class="math display" id="eq:pendulum-state-affine">\[\begin{equation}
\begin{split}
\dot{x} &amp; = \underbrace{\begin{bmatrix}
0 &amp; 1 \\
0 &amp; - \frac{b}{ml^2}
\end{bmatrix}}_{=:A} x +
\underbrace{\begin{bmatrix}
0 \\
\frac{u - mgl \sin \theta }{ml^2}
\end{bmatrix}}_{=:B(u,y)} \\
y &amp; = \underbrace{\begin{bmatrix}
1 &amp; 0
\end{bmatrix}}_{=:C} x
\end{split}.
\tag{5.14}
\end{equation}\]</span></p>
<p>In order for us to use the Luenberger observer, we need to check if the pair <span class="math inline">\((A,C)\)</span> is detectable. We can easily find the eigenvalues and eigenvectors of <span class="math inline">\(A\)</span>:
<span class="math display">\[
A \begin{bmatrix}
1 \\ 0
\end{bmatrix} = 0,\quad
A \begin{bmatrix}
- \frac{ml^2}{b} \\ 1
\end{bmatrix} = \begin{bmatrix}
1 \\ - \frac{b}{ml^2}
\end{bmatrix}
= - \frac{b}{ml^2} \begin{bmatrix}
- \frac{ml^2}{b} \\ 1 \end{bmatrix}.
\]</span>
The first eigenvalue has real part equal to <span class="math inline">\(0\)</span>. However,
<span class="math display">\[
C \begin{bmatrix}
1 \\ 0
\end{bmatrix} = 1 \neq 0.
\]</span>
According to Theorem <a href="linear-system-theory.html#thm:ltidetectable">A.3</a>, we conclude <span class="math inline">\((A,C)\)</span> is detectable. In fact, the pair <span class="math inline">\((A,C)\)</span> is more than just detectable, it is indeed observable (according to Theorem <a href="linear-system-theory.html#thm:ltiobservable">A.2</a>). Therefore, the poles of <span class="math inline">\(A - KC\)</span> can be arbitrarily placed.</p>
<p>Now we need to find <span class="math inline">\(K\)</span>. An easy choice of <span class="math inline">\(K\)</span> is
<span class="math display">\[
K = \begin{bmatrix} k \\ 0 \end{bmatrix}, \quad A - KC =
\begin{bmatrix}
- k &amp; 1 \\ 0 &amp; - \frac{b}{ml^2}
\end{bmatrix}.
\]</span>
With <span class="math inline">\(k &gt; 0\)</span>, we know <span class="math inline">\(A- KC\)</span> is guaranteed to be Hurwitz (the two eigenvalues of <span class="math inline">\(A-KC\)</span> are <span class="math inline">\(-k\)</span> and <span class="math inline">\(-b/ml^2\)</span>), and we have obtained an observer!</p>
<p>Oftentimes, it is insufficient to ensure the estimator converges to the true state asymptotically, and we need to reason about the convergence rate. Particularly, let us define <span class="math inline">\(e = \hat{x} - x\)</span>, and we know
<span class="math display">\[
\dot{e} = H e, \quad H = A - KC.
\]</span>
Suppose we are interested in understanding the convergence rate of the squared norm of the error signal, that is,
<span class="math display">\[
V = e^T e.
\]</span>
Differentiating <span class="math inline">\(V\)</span> we obtain
<span class="math display">\[
\dot{V} = 2 \dot{e}^T e = e^T (H + H^T) e
\]</span></p>
<p><span style="color:red">TBD: simulate the observer.</span></p>
</div>
</div>
</div>
<div id="state-affine-template" class="section level3 hasAnchor" number="5.1.3">
<h3><span class="header-section-number">5.1.3</span> State-affine Template<a href="output-feedback.html#state-affine-template" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Consider an instance of the normal form <a href="output-feedback.html#eq:meta-observer-zeta">(5.7)</a> where the dynamics is linear in <span class="math inline">\(\xi\)</span>, but the coefficients are time-varying and dependent on the input and output
<span class="math display" id="eq:state-affine-template">\[\begin{equation}
\dot{\xi} = A(u,y) \xi + B(u,y), \quad y = C(u) \xi.
\tag{5.15}
\end{equation}\]</span>
The difference between the state-affine template <a href="output-feedback.html#eq:state-affine-template">(5.15)</a> and the Luenberger template <a href="output-feedback.html#eq:Luenberger-linear-template">(5.10)</a> is that the linear matrices <span class="math inline">\(A,C\)</span> are allowed to depend nonlinearly on the input <span class="math inline">\((u,y)\)</span>.</p>
<p>Kalman and Bucy originally proposed an observer for linear time-varying systems <span class="citation">(<a href="#ref-kalman61-new">Kalman and Bucy 1961</a>)</span>. The result is later extened by <span class="citation">(<a href="#ref-besanccon96ejc-observer">Besançon, Bornard, and Hammouri 1996</a>)</span> and <span class="citation">(<a href="#ref-hammouri90cdc-observer">Hammouri and Leon Morales 1990</a>)</span> to deal with coefficient matrices dependent on the control. The following theorem is a direct extension of the result from <span class="citation">(<a href="#ref-besanccon96ejc-observer">Besançon, Bornard, and Hammouri 1996</a>)</span> and <span class="citation">(<a href="#ref-hammouri90cdc-observer">Hammouri and Leon Morales 1990</a>)</span> by considering <span class="math inline">\((u,y)\)</span> as an augmented control input.</p>
<p>Before presenting the theorem, we need to introduce the following terminology.</p>
<div class="definition">
<p><span id="def:lineartimevarying" class="definition"><strong>Definition 5.2  (Linear Time-Varying System) </strong></span>For a linear time-varying system of the form
<span class="math display" id="eq:linear-time-varying">\[\begin{equation}
\dot{\chi} = A(\nu) \chi, \quad y = C(\nu) \chi,
\tag{5.16}
\end{equation}\]</span>
with input <span class="math inline">\(\nu\)</span> and output <span class="math inline">\(y\)</span>, we define</p>
<ul>
<li><p>the <em>transition matrix</em> <span class="math inline">\(\Psi_\nu\)</span> as the unique solution to
<span class="math display">\[
\Psi_\nu (t,t) = I, \quad \frac{\partial \Psi_\nu}{\partial \tau}(\tau,t) = A(\nu(\tau)) \Psi_\nu (\tau, t).
\]</span>
Note that the transition matrix is used to express the solution to <a href="output-feedback.html#eq:linear-time-varying">(5.16)</a> because it satisfies
<span class="math display">\[
\chi(\chi_0,t_0;t;\nu) = \Psi_\nu (t,t_0) \chi_0.
\]</span></p></li>
<li><p>the <em>observability grammian</em> as
<span class="math display">\[
\Gamma_\nu (t_0,t_1) = \int_{t_0}^{t_1} \Psi_\nu (\tau,t_0)^T C(\nu(\tau))^T C(\nu(\tau)) \Psi_\nu (\tau,t_0) d\tau.
\]</span></p></li>
<li><p>the <em>backward observability grammian</em> as
<span class="math display">\[
\Gamma_\nu^b (t_0,t_1) = \int_{t_0}^{t_1} \Psi_\nu (\tau,t_1)^T C(\nu(\tau))^T C(\nu(\tau)) \Psi_\nu (\tau,t_1) d\tau.
\]</span></p></li>
</ul>
</div>
<p>We now introduce the Kalman-Bucy Observer for the state-affine template <a href="output-feedback.html#eq:state-affine-template">(5.15)</a>.</p>
<div class="theorembox">
<div class="theorem">
<p><span id="thm:kalmanbucystateaffine" class="theorem"><strong>Theorem 5.3  (Kalman-Bucy Observer) </strong></span>Let <span class="math inline">\(y_{\xi_0,u}(t) = C(u(t)) \Xi (\xi_0;t;u)\)</span> be the output of system <a href="output-feedback.html#eq:state-affine-template">(5.15)</a> at time <span class="math inline">\(t\)</span> with initialization <span class="math inline">\(\xi_0\)</span> and control <span class="math inline">\(u\)</span>. Suppose the control <span class="math inline">\(u\)</span> satisfies</p>
<ul>
<li><p>For any <span class="math inline">\(\xi_0\)</span>, <span class="math inline">\(t \mapsto A(u(t),y_{\xi_0,u}(t))\)</span> is bounded by <span class="math inline">\(A_{\max}\)</span></p></li>
<li><p>For any <span class="math inline">\(\xi_0\)</span>, the augmented input <span class="math inline">\(\nu = (u,y_{\xi_0,u})\)</span> is <em>regularly persistent</em> for the dynamics
<span class="math display" id="eq:kbobserver-auxilarydynamics">\[\begin{equation}
\dot{\chi} = A(\nu) \chi , \quad y = C(\nu) \chi
\tag{5.17}
\end{equation}\]</span>
uniformly with respect to <span class="math inline">\(\xi_0\)</span>. That is, there exist strictly positive numbers <span class="math inline">\(t_0,\bar{t}\)</span>, and <span class="math inline">\(\alpha\)</span> such that for any <span class="math inline">\(\xi_0\)</span> and any time <span class="math inline">\(t \geq t_0 \geq \bar{t}\)</span>,
<span class="math display">\[
\Gamma_v^b (t-\bar{t}, t) \succeq \alpha I,
\]</span>
where <span class="math inline">\(\Gamma_v^b\)</span> is the <em>backward observability grammian</em> associated with system <a href="output-feedback.html#eq:kbobserver-auxilarydynamics">(5.17)</a>.</p></li>
</ul>
<p>Then, given any positive definite matrix <span class="math inline">\(P_0\)</span>, there exist <span class="math inline">\(\alpha_1,\alpha_2 &gt; 0\)</span> such that for any <span class="math inline">\(\lambda \geq 2 A_{\max}\)</span> and any <span class="math inline">\(\xi_0 \in \mathbb{R}^p\)</span>, the matrix differential equation
<span class="math display" id="eq:kbobserver-matrixdifferential">\[\begin{equation}
\dot{P} = -\lambda P - A(u,y)^T P - P A(u,y) + C(u)^T C(u)
\tag{5.18}
\end{equation}\]</span>
initialized at <span class="math inline">\(P(0) = P_0\)</span> admits a unique solution satisfying <span class="math inline">\(P(t)=P(t)^T\)</span> and
<span class="math display">\[
\alpha_2 I \succeq P(t) \succeq \alpha_1 I.
\]</span>
Moreover, the system
<span class="math display" id="eq:kbobserver-observer">\[\begin{equation}
\dot{\hat{\xi}} = A(u,y) \hat{\xi} + B(u,y) + K (y - C(u)\hat{\xi})
\tag{5.19}
\end{equation}\]</span>
with a time-varying gain matrix
<span class="math display" id="eq:kbobserver-gain">\[\begin{equation}
K = P^{-1} C(u)^T
\tag{5.20}
\end{equation}\]</span>
is an observer for the state-affine system <a href="output-feedback.html#eq:state-affine-template">(5.15)</a>.</p>
</div>
</div>
<p>Let us work out an example of the Kalman-Bucy Observer for nonlinear systems.</p>
<div class="examplebox">
<div class="example">
<p><span id="exm:pendulumkbobserver" class="example"><strong>Example 5.2  (Kalman-Bucy Observer for A Simple Pendulum) </strong></span>Let us reconsider the pendulum dynamics <a href="output-feedback.html#eq:kbobserver-pendulum">(5.13)</a> but this time try to design a Kalman-Bucy observer.</p>
<p>We first write the pendulum dynamics in a new coordinate system so that it is in the state-affine normal form <a href="output-feedback.html#eq:state-affine-template">(5.15)</a>. We choose <span class="math inline">\(\xi = [\mathfrak{s},\mathfrak{c},\dot{\theta}]^T\)</span> with <span class="math inline">\(\mathfrak{s} = \sin \theta\)</span> and <span class="math inline">\(\mathfrak{c} = \cos \theta\)</span>. Clearly, we will be able to observe <span class="math inline">\(y = [\mathfrak{s},\mathfrak{c}]^T\)</span> in this new coordinate. The state-affine normal form of the pendulum dynamics reads
<span class="math display" id="eq:pendulum-state-affine">\[\begin{equation}
\begin{split}
\dot{\xi} = \begin{bmatrix}
\mathfrak{c} \dot{\theta} \\
- \mathfrak{s} \dot{\theta} \\
- \frac{1}{ml^2} (b \dot{\theta} + mgl \mathfrak{s} ) +  \frac{1}{ml^2} u
\end{bmatrix} &amp; =
\underbrace{\begin{bmatrix}
0 &amp; 0 &amp; \mathfrak{c} \\
0 &amp; 0 &amp; -\mathfrak{s} \\
0 &amp; 0 &amp; -\frac{b}{ml^2}
\end{bmatrix}}_{=:A(u,y)} \xi +
\underbrace{\begin{bmatrix}
0 \\ 0 \\ \frac{u - mgl \mathfrak{s}}{ml^2}
\end{bmatrix}}_{=:B(u,y)} \\
y &amp; = \underbrace{\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0
\end{bmatrix}}_{=:C(u)} \xi
\end{split}.
\tag{5.14}
\end{equation}\]</span>
Note that <span class="math inline">\(C(u)\)</span> is in fact time-invariant, and <span class="math inline">\(B(u,y)\)</span> only depends on <span class="math inline">\(u\)</span>; but we adopt the same notation as the general state-affine template <a href="output-feedback.html#eq:state-affine-template">(5.15)</a>.</p>
<p>In order to use the Kalman-Bucy observer in Theorem <a href="output-feedback.html#thm:kalmanbucystateaffine">5.3</a>, we need to verify the boundedness of <span class="math inline">\(A(u,y)\)</span>, and the regular persistence of <a href="output-feedback.html#eq:kbobserver-auxilarydynamics">(5.17)</a>.</p>
<p><strong>Boundedness of <span class="math inline">\(A(u,y)\)</span></strong>. We can easily show the boundedness of <span class="math inline">\(A(u,y)\)</span> by writing
<span class="math display">\[
\Vert A(u,y) \xi \Vert = \Vert \xi_3 (\mathfrak{c} - \mathfrak{s} - b/ml^2) \Vert  \leq |\xi_3| \sqrt{3} \sqrt{\mathfrak{c}^2 + \mathfrak{s}^2 + b^2 / m^2 l^4} \leq \Vert \xi \Vert \sqrt{3 + 3b^2 / m^2 l^4}.
\]</span>
Therefore, we can take <span class="math inline">\(A_{\max} = \sqrt{3 + 3b^2 / m^2 l^4}\)</span>.
<span style="color:red">Does the <span class="math inline">\(A_{\max}\)</span> in Theorem <a href="output-feedback.html#thm:kalmanbucystateaffine">5.3</a> refer to the bound in operator norm?</span></p>
<p><strong>Regular persistence</strong>. We write the backward observability grammian of system <a href="output-feedback.html#eq:kbobserver-auxilarydynamics">(5.17)</a>
<span class="math display">\[
\Gamma_\nu^b(t - \bar{t},t) = \int_{t - \bar{t}}^t \Psi_\nu(\tau,t)^T C^T C \Psi_\nu (\tau, t) d \tau = \int_{t - \bar{t}}^t \Psi_\nu(\tau,t)^T \begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0
\end{bmatrix}
\Psi_\nu (\tau, t) d \tau
\]</span>
<span style="color:red">Does the transition matrix <span class="math inline">\(\Psi_\nu (\tau, t)\)</span> have an analytical form?</span></p>
</div>
</div>
</div>
<div id="triangular-template" class="section level3 hasAnchor" number="5.1.4">
<h3><span class="header-section-number">5.1.4</span> Triangular Template<a href="output-feedback.html#triangular-template" class="anchor-section" aria-label="Anchor link to header"></a></h3>

</div>
</div>
</div>
<h3>References<a href="references.html#references" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-astolfi03tac-immersion" class="csl-entry">
Astolfi, Alessandro, and Romeo Ortega. 2003. <span>“Immersion and Invariance: A New Tool for Stabilization and Adaptive Control of Nonlinear Systems.”</span> <em>IEEE Transactions on Automatic Control</em> 48 (4): 590–606.
</div>
<div id="ref-bernard19book-observer" class="csl-entry">
Bernard, Pauline. 2019. <em>Observer Design for Nonlinear Systems</em>. Vol. 479. Springer.
</div>
<div id="ref-bernard22arc-observer" class="csl-entry">
Bernard, Pauline, Vincent Andrieu, and Daniele Astolfi. 2022. <span>“Observer Design for Continuous-Time Dynamical Systems.”</span> <em>Annual Reviews in Control</em>.
</div>
<div id="ref-besanccon96ejc-observer" class="csl-entry">
Besançon, Gildas, Guy Bornard, and Hassan Hammouri. 1996. <span>“Observer Synthesis for a Class of Nonlinear Control Systems.”</span> <em>European Journal of Control</em> 2 (3): 176–92.
</div>
<div id="ref-hammouri90cdc-observer" class="csl-entry">
Hammouri, Hassan, and Jesus de Leon Morales. 1990. <span>“Observer Synthesis for State-Affine Systems.”</span> In <em>29th IEEE Conference on Decision and Control</em>, 784–85. IEEE.
</div>
<div id="ref-kalman61-new" class="csl-entry">
Kalman, Rudolph E, and Richard S Bucy. 1961. <span>“New Results in Linear Filtering and Prediction Theory.”</span>
</div>
<div id="ref-karagiannis05cdc-nonlinear" class="csl-entry">
Karagiannis, Dimitrios, and Alessandro Astolfi. 2005. <span>“Nonlinear Observer Design Using Invariant Manifolds and Applications.”</span> In <em>Proceedings of the 44th IEEE Conference on Decision and Control</em>, 7775–80. IEEE.
</div>
</div>
<div class="footnotes">
<hr />
<ol start="4">
<li id="fn4"><p>We say “any solution” because there may be several solutions to the observer <a href="output-feedback.html#eq:observer-definition-1">(5.2)</a> due to <span class="math inline">\(\mathcal{F}\)</span> only being continuous. This is not a problem as long as any such solution satisfies the required convergence property.<a href="output-feedback.html#fnref4" class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p>The time dependence of <span class="math inline">\(\mathcal{T}_u\)</span> enables us to cover the case where the knowledge of the <span class="math inline">\(u\)</span> and <span class="math inline">\(y_{x_0,u}\)</span> is used to construct the estimate from the observer state. In particular, using the output sometimes can reduce the dimension of the observer state (and thus alleviate the computations), thus obtaining a reduced-order observer. For example, see <span class="citation">(<a href="#ref-karagiannis05cdc-nonlinear">Karagiannis and Astolfi 2005</a>)</span> and <span class="citation">(<a href="#ref-astolfi03tac-immersion">Astolfi and Ortega 2003</a>)</span>.<a href="output-feedback.html#fnref5" class="footnote-back">↩︎</a></p></li>
<li id="fn6"><p>A function <span class="math inline">\(\rho: \mathbb{R}_+ \rightarrow \mathbb{R}_+\)</span> is a <span class="math inline">\(\mathcal{K}\)</span> function if <span class="math inline">\(\rho(0) = 0\)</span>, <span class="math inline">\(\rho\)</span> is continuous, and <span class="math inline">\(\rho\)</span> is increasing.<a href="output-feedback.html#fnref6" class="footnote-back">↩︎</a></p></li>
<li id="fn7"><p>An injective function is a function <span class="math inline">\(f\)</span> that maps distinct elements of its domain to distinct elements. That is, <span class="math inline">\(f(x_a) = f(x_b)\)</span> implies <span class="math inline">\(x_a = x_b\)</span>, or equivalently, <span class="math inline">\(x_a \neq x_b\)</span> implies <span class="math inline">\(f(x_a) \neq f(x_b)\)</span>.<a href="output-feedback.html#fnref7" class="footnote-back">↩︎</a></p></li>
<li id="fn8"><p>I have to say I was a bit surprised when I arrived at this formulation.<a href="output-feedback.html#fnref8" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="stability.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="adaptivecontrol.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/hankyang94/OptimalControlEstimation/blob/main/06-output-feedback.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["optimal-control-estimation.pdf", "optimal-control-estimation.epub"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
